## 1. Project overview

This project produces a microservice which is deployed to a kubernetes cluster on AWS. Main idea is that it can be reused for other
more meaningfull microservice projects.

### 1.1 Microservice data

```json
{
    "service-name": "blue",           # configured inside ConfigMap during deployment
    "pod-ip-addr": "10.0.3.26",
    "pod-hostname": "",
    "version": "1.1",                 # version as defined by developer
    "version-long": "8-1.1-017472",   # generate by CI/CD
    "now": "2024-01-28 02:32:32",
    "seq-counter:": 11                # used to detect pod restart
}
```

### 1.2 Service version explained

Service version is generated by CI/CD and is available inside deployed service as environment variable.

```cpp
//  +--------------- Build version (GITHUB_RUN_NUMBER), incremented with each workflow execution
//  |   +----------- Software version extracted from source code
//  |   |      +---- Git commit SHA (first 6 symbols)
//  |   |      |
    8-1.1-017472
```

## 2. Git branching strategy

1. `master` branch is protected. Require a pull request before merging. All commits must be made to a non-protected branch and submitted via a pull request before they can be merged into a branch that matches this rule.
2. All modifications happen throug _feature_ branches which should start with `feat-`
   * when ready a PR is created and `feat-` branch is merged to `master`

   ![branch-strategy](doc/feature-branches.png)
3. Deployments are done only from `master` branch through a CI\CI pipeline

   ![branch-strategy](doc/branch-strategy.png)

## 3. CI/CD overview

```text
    GitHub
                  on pull request OK:
                    * gen Docker images
  +------------+    * gen deployment     +-----------+
  |  src_repo  | ----.     .-----------> | depl_repo |
  +------------+      \   /              +-----------+
                       \ /                 ^
                        V                  |
                    +-----------+          |
                    | Dockerhub |          |
                    |  repo     |          |
                    +-----------+          |
                                           |
    AWS                                    | monitor for changes
                                           |
   +---------------------------------------|--------+
   |    Kubernetes (AWS EKS)               |        |
   |                                  +--------+    |
   |        +-------------------------| ArgoCD |    |
   |        |     deploy              +--------+    |
   |        V                                       |
   |  +-----------+                                 |
   |  |  my app   |                                 |
   |  +-----------+                                 |
   +------------------------------------------------+

```

### 3.1 Application deployment repo

CI/CD pipeline updates [istio-tryout-deployment](https://github.com/yulian-matev/istio-tryout-deployment) repository with:

* all _.yml_ files from `deployment-template` directory
* inside all _.yml_ templates, patter `__TAG__` is replaced with generated docker image tag

## 4. Secrets and security

### 4.1. Secrets management

Following secrets are stored safely inside GibHub

* `DOCKERHUB_TOKEN` - used to push produced docker images to DockerHub
* `MY_GITHUB_TOKEN` - used for updating _deployment repo_ [istio-tryout-deployment](https://github.com/yulian-matev/istio-tryout-deployment)
* `SNYK_TOKEN`  - used for security scanner
* `SONAR_TOKEN` - used for security scanner

No secrets are kept inside ArgoCD because _deployment repo_ and _dockerhub repo_ are public.

### 4.2. Security checks

Several security checks are performed before software is deployed:

* Gitleaks - hardcoded secrets like passwords, api keys, and tokens in git repos.
* SonarCloud - code quality and security
* PHP syntax checker (lint)

## 6. Initalize AWS infrastructure

### Infrastructure precondition

For a successful infrastructure provisioning we need:

* active AWS acount and `aws` command line tool
* `terraform` installed locally
* `ansible`
* `istioctl`
* `kubectl`

    ```bash
      cd infrastructure-eks
      terraform init             # initialize backend - need to be called once
      # terraform plan           # optional
      terraform apply            # create/upddate infrastructure

    ```

### Configure local `kubectl` to access AWS EKS cluster

1. Confugre credentials for `awscli`

    ```bash
      asw cofigure

      # std input:
      #access_key: AKIxxxxxxxxxxxxxxxxx
      #secret_key: h6V/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

    ```

2. Transfer credentials from `awscli` to `kubectl` (file `/home/user/.kube/config` gets updated):

    ```bash
    aws eks update-kubeconfig --region <region> --name <cluster-name>
    # aws eks update-kubeconfig --region eu-central-1 --name education-eks-iCgeDNNU
    ```

### Install ArgoCD

Install and verify:

```bash
cd infrastructure-cfg
ansible-playbook playbook_argo.yml

# verify installation:
kubectl get pods,svc -n argocd

# get admin password:
kubectl get secret argocd-initial-admin-secret -n argocd -o yaml

# open Argo web UI on https://localhost:8080
kubectl port-forward svc/argocd-server -n argocd 8080:443
```

### Observability Add-ons

```bash
kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/prometheus.yaml
kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/grafana.yaml
kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/kiali.yaml
kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/jaeger.yaml
```



```bash
# Visualize Istio Mesh console using Kiali
kubectl port-forward svc/kiali 20001:20001 -n istio-system

# Get to the Prometheus UI
kubectl port-forward svc/prometheus 9090:9090 -n istio-system

# Visualize metrics in using Grafana
kubectl port-forward svc/grafana 3000:3000 -n istio-system

# Visualize application traces via Jaeger
kubectl port-forward svc/jaeger 16686:16686 -n istio-system
```
